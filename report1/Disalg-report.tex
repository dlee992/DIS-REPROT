%!TEX TS-program = XeLaTeX
\documentclass[UTF8]{article}

%--
\usepackage{ctex}
\usepackage[margin=1in]{geometry}

%--
\begin{document}
    
%--
{\flushleft \bf \Large 姓名：} 李达 (程序合成)
{\flushleft \bf \Large 旧学号：} DZ1633007
{\flushleft \bf \Large 新学号：} MG1633116
{\flushleft \bf \Large 日期：} 2020.11.17

%=========================================================================
\section*{论文信息}
\begin{itemize}
    \item Lamport, L. (1978). Time, clocks, and the ordering of events in a distributed system. 
    \textit{Commun. ACM}, 21(7):558–565.
    \item Mattern, F. (1989). Virtual time and global states of distributed systems. 
    \textit{In Proc. International Workshop on Parallel and Distributed Algorithms}, pages 215–226, Holland.
\end{itemize}
下文分别称之为“文章1”和“文章2”。
    
%=========================================================================
\section{总序}

在分布式系统中，进程中不同事件的执行顺序引起理论和实践的广泛关注。
为了刻画不同事件的执行顺序，需要确定如何描述时间，然后确定如何在事件执行时进行计时，进而根据不同事件的时间戳来确定执行顺序关系。
这两篇文章主要围绕这些关键点，描述了三种递进的描述时间的方法：逻辑时钟，物理时钟，和向量时钟。
下面先分析不同事件之间存在的顺序关系，再结合特定的分布式场景分别对三种计时方法进行讨论。

%=========================================================================
\section{分布式系统的假设}

\subsection{事件集合的偏序性}
首先，我们假设在理想情况下，进程事件都是原子执行的。那么，任意给定两个事件（不管是否属于同一个进程），记为$e_i$，$e_j$，
只可能存在两种关系：$e_i \rightarrow e_j$（或反向）或者$e_i\ ||\ e_j$，即要么$e_i$先于$e_j$执行（反向情况下，$e_j$先于$e_i$执行），或者两个并发执行。
那么，对于具有多个进程的分布式系统，所有事件之间的关系构成了一个偏序集。

\subsection{现实场景的约束}

\begin{itemize}
    \item 分布式系统中，两个不同的进程进行消息发送和接受，其中的网络延迟是不可预估的。
    \item 分布式系统中，无法让不同的进程拥有一个全局物理时钟。
\end{itemize}
上述两点现实约束，要求每个进程维护一个本地的时钟，
通过消息发送来告知其他进程自身的时间戳，通过消息接受来了解其他进程的时间戳，进而刻画事件之间的偏序关系。

%=========================================================================
\section{逻辑时钟}
\subsection{设计思路}
设计逻辑时钟的出发点也很简单，如果能给每个事件赋一个整数（把这个映射函数记为$C$，$C\langle e \rangle$即表示赋予事件$e$的整数），表示该事件执行的具体时间戳，那就可以在“一定程度”上刻画事件之间的偏序关系。
在分布式系统中，我们首先关注事件之间的先后关系，因此先要确保Clock Condition性质得到满足：

\textbf{对于任意的两个事件$e_i$ 和 $e_j$，如果 $e_i \rightarrow e_j$，那么$C\langle e_i \rangle < C \langle e_j\rangle$。}

这里提到的先于发生关系来自于分布式系统事件之间两类固有的关系：单个进程上事件发生的局部先后关系，
以及一个消息的发送和接受对应的两个事件之间的先后关系。
注意到，这个Clock Condition的条件和结论不能颠倒，而这一点正是逻辑时钟的缺陷所在，第五部分会具体分析。

在文章1中，Lamport给出了一个可行的赋值方案，只需在系统执行过程中，按照以下两条规则来维护每个进程的局部逻辑时钟：
\begin{itemize}
    \item \textbf{IR1. 每个进程$P_i$在任意两个局部连续事件之间增加自身的逻辑时钟$C_i$。}
    \item \textbf{IR2. 
        \begin{itemize}
            \item 如果事件$e_i$是进程$P_i$发送消息$m$的发送事件，那么消息$m$会包含一个时间戳$T_m=C_i \langle e_i \rangle$。
            \item 一旦接受到消息$m$，进程$P_j$就将自身的逻辑时钟$C_j$设置为大于等于当前值，并且大于$T_m$。
        \end{itemize} 
    }
\end{itemize}
这一设计思路，就能够使得每个进程的逻辑时钟满足Clock Condition的要求。

\subsection{应用场景}
\subsubsection{全序}
根据$C$函数的映射可以刻画事件之间的偏序关系，对于两个事件具有相同逻辑时间戳的情况，额外对进程进行排序即可。

\subsubsection{资源互斥访问}
首先分布式的资源互斥访问过程要分三步：进程请求资源，授予进程资源，进程释放资源。
利用上一小节得到的全序关系，来实现资源互斥访问需要做到如下三点：
\textbf{
\begin{itemize}
    \item 在资源被授予另一个进程之前，上一个被授予资源的进程必须先释放资源。
    \item 不同的资源请求必须以请求的时间戳排序进行按序访问。
    \item 如果每个被授予资源的进程最终都会释放它，那么每个请求最终都会被授予资源访问权限。
\end{itemize}}

在设计具体的算法前，先有一些简化的假设：对于任意两个进程，从$P_i$发送到$P_j$的消息的到达顺序和发送顺序保持一致；
另外，假设每个消息最终都会到达，不会丢失；以及假设每个进程都可以直接向其他进程发送消息。
在给每个进程分配一个单独的请求队列基础上，Lamport设计出了相应的算法来实现资源互斥访问：
\textbf{
\begin{itemize}
    \item 为了请求资源，进程$P_i$发送消息$T_{m}:P_{i}\ requests\ resource$给其他所有进程，
    并发此消息加入自身的请求队列中，其中的$T_m$就是消息的时间戳。
    \item 当进程$P_j$收到消息$T_{m}:P_{i}\ requests\ resource$时，把此消息放入到自身的请求队列中，并发送带时间戳的确认消息给$P_i$。
    \item 为了释放资源，进程$P_i$从自身的请求队列中移除$T_{m}:P_{i}\ requests\ resource$消息，同时广播一个带时间戳的消息$P_i\ releases\ resource$。
    \item 当进程$P_j$收到$P_i\ releases\ resource$消息时，也将$T_{m}:P_{i}\ requests\ resource$消息从自身的请求队列中移除。
    \item 当进程$P_i$满足以下两个条件时，将资源授予给它：
        \begin{itemize}
            \item 在它的请求队列中存在一条$T_{m}:P_{i}\ requests\ resource$的消息，并且在全序上先于队列中的所有其他消息。
            \item $P_i$已经收到了所有其他进程发送的消息带有超过$T_m$的时间戳。
        \end{itemize}
\end{itemize}}
直觉上，上述算法似乎能够很好得满足之前提出的三点要求，即授予前先释放，并发请求按序访问，以及执行的终止性。
证明略过。似乎可以编写一些单机下的多线程测试用例来尝试模拟这个算法的执行过程，应该会有更好的理解。
    
%=========================================================================
\section{物理时钟？}
% \subsection{我的困惑}
文章１里在后半部分讲述一个分布式系统中，仍然会有一些系统外部的happen-before关系，然后就开始设计物理时钟来刻画这一新关系？
我没有理解，这所谓外部新的happen-before关系，和之前基于消息传递和单进程内部事件顺序的happen-before关系有何区别？
何苦要新的方式来描述和刻画？
这点没想明白。

在这之后针对物理时钟进行的形式化描述，看上去是为了让时钟模型更加贴近生活中的时钟工作模式？为了啥呢？

%=========================================================================
\section{线性时钟的固有缺陷}
这里线性时钟指代的是用一维向量，或者说就是一个数字，来记录事件执行的时间戳的方法，上文提到的逻辑时钟，物理时钟都是典型的线性时钟。
根据Clock Condition，不难发现，对于具有happen-before关系的事件，事件对应的时间戳也具有相应的大小关系。
但是，反过来，事件对应的时间戳不相等时，并不能推导出事件之间是并发关系还是happen-before关系。
这一点，正是线性时钟的固有缺陷：真实的事件之间的关系，并不能够通过线性时钟及其对应的时间戳来完整刻画，映射后的线性时钟丢失了一些信息。

%=========================================================================
\section{向量时钟}
\subsection{设计思路}
文章２中，向量时钟的设计初衷就是为了通过新思路来弥补线性时钟的“丢失信息”的固有缺陷，希望映射后的新时间戳能够精准地反推到事件关系。

向量时钟的设计也比较简单直接，还是根据两类固有的happen-before事件来更新每个进程的向量时钟，这里假设每个进程$P_i$都有一个向量时钟$C_i$，即一个$n$维向量，
$n$就是系统中进程的总数。$C_i$的更新策略有两条：
\textbf{
\begin{itemize}
    \item 进程$P_i$在执行一个事件时自曾向量时钟中属于自身的那一维，即$C_{i}[i]:=C_{i}[i]+1$。
    \item 当进程$P_i$发送消息时，会附上当前进程的向量时间戳$t=C_{i}[i]$。
    \item 当进程$P_j$收到消息时，自身的向量时钟会被更新$C_i := sup(C_i,t)$，这里$sup(u,v)=w$，其中对每一维度满足$w[i]=max(u[i],v[i])$。
\end{itemize}}
通过向量时间戳来映射每个事件的执行事件就能够保证如下性质：
\textbf{
\begin{itemize}
    \item 对任意两个事件，$e_i\rightarrow e_j$，当且仅当$C\langle e_i \rangle < C\langle e_j \rangle$。
    \item 对任意两个事件，$e_i || e_j$，当且仅当$\neg (C\langle e_i \rangle < C\langle e_j \rangle) \wedge (\neg (C\langle e_j \rangle < C\langle e_i \rangle))$。
\end{itemize}}
也就是说，事件之间的happen-before关系和并发关系，能够通过时钟向量完美映射，并可以相互推导。这也跟时钟向量构成了偏序格有关。
\subsection{应用场景}
\subsubsection{获取分布式系统快照}
具体的算法步骤就不赘述了，一个算法设计灵感的关键点在于，如何给定一个统一的虚拟时间点来让每个进程保存自身状态，以便组成一个全局的具有一致性的系统快照。
这里用到了几个关于向量时钟的推导结果，其中一个比较关键的是：

\textbf{在向量时钟$C_i$更新的时刻,$ \neg \exists j:C_i < C_j $。}

也就是说只要一个向量时钟正在更新的过程中，就可以由该进程发起一次全局快照请求，
对应的虚拟时间就可以使用当前进程的向量时间戳。

%=========================================================================
\section{总结}
能够刻画并处理分布式系统中事件之间的执行顺序非常关键，因此通过时间模型和对应的时间戳来表征事件执行时间显得尤为重要。
这应当是研究分布式算法和系统时的一个基础性问题，之前也了解过Paxos和Raft协议，不过一直没有很深刻的理解，
也许通过这次循序渐进的阅读经典论文，能够对中上层的协议，算法，和系统有更深入的认知。

\end{document}